<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>现代硬件的高效查询计划的高效编译 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="作者1234Thomas NeumannTechnische Universit ¨ at M ¨ unchenMunich, Germanyneumann@in.tum.de 摘要随着内存的增长，查询性能越来越取决于处理查询的原始CPU的代价。经典的迭代器式查询处理十分简单并且十分灵活，由于程序的局部性不好、与频繁指令预测失误，导致在现代CPU下展现出性能不佳，在过去，使用面向批量处理方式与元组">
<meta name="keywords" content="“database”">
<meta property="og:type" content="article">
<meta property="og:title" content="现代硬件的高效查询计划的高效编译">
<meta property="og:url" content="http://yoursite.com/2019/07/08/现代硬件的高效查询计划的高效编译/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="作者1234Thomas NeumannTechnische Universit ¨ at M ¨ unchenMunich, Germanyneumann@in.tum.de 摘要随着内存的增长，查询性能越来越取决于处理查询的原始CPU的代价。经典的迭代器式查询处理十分简单并且十分灵活，由于程序的局部性不好、与频繁指令预测失误，导致在现代CPU下展现出性能不佳，在过去，使用面向批量处理方式与元组">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/FigureHandWriteen.png">
<meta property="og:image" content="http://yoursite.com/images/Fig3ExamplePlan.png">
<meta property="og:image" content="http://yoursite.com/images/Fig4-Compile.png">
<meta property="og:image" content="http://yoursite.com/images/Fig5Asimpletranslation.png">
<meta property="og:image" content="http://yoursite.com/images/Fig6-InteractionOfLLVM.png">
<meta property="og:image" content="http://yoursite.com/images/Fig7-LLVMFragment.png">
<meta property="og:image" content="http://yoursite.com/images/Tab1OLTP.png">
<meta property="og:image" content="http://yoursite.com/images/Tab2OLAP.png">
<meta property="og:image" content="http://yoursite.com/images/Tab3BranchingAndCache.png">
<meta property="og:image" content="http://yoursite.com/images/Fig8CascadeSelection.png">
<meta property="og:image" content="http://yoursite.com/images/Fig9PerformanceAggreQue.png">
<meta property="og:updated_time" content="2019-08-08T03:19:49.186Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="现代硬件的高效查询计划的高效编译">
<meta name="twitter:description" content="作者1234Thomas NeumannTechnische Universit ¨ at M ¨ unchenMunich, Germanyneumann@in.tum.de 摘要随着内存的增长，查询性能越来越取决于处理查询的原始CPU的代价。经典的迭代器式查询处理十分简单并且十分灵活，由于程序的局部性不好、与频繁指令预测失误，导致在现代CPU下展现出性能不佳，在过去，使用面向批量处理方式与元组">
<meta name="twitter:image" content="http://yoursite.com/images/FigureHandWriteen.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>
</html>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-现代硬件的高效查询计划的高效编译" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/现代硬件的高效查询计划的高效编译/" class="article-date">
  <time datetime="2019-07-08T08:03:44.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      现代硬件的高效查询计划的高效编译
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thomas Neumann</span><br><span class="line">Technische Universit ¨ at M ¨ unchen</span><br><span class="line">Munich, Germany</span><br><span class="line">neumann@in.tum.de</span><br></pre></td></tr></table></figure></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>随着内存的增长，查询性能越来越取决于处理查询的原始CPU的代价。经典的迭代器式查询处理十分简单并且十分灵活，由于程序的局部性不好、与频繁指令预测失误，导致在现代CPU下展现出性能不佳，在过去，使用面向批量处理方式与元组矢量化处理方式对这种情况有所改善，但这些表现突出的技术经常采用手写执行计划的方式来实现。</p>
<p>本文中我们提出一个新颖的编译策略，使用LLVM框架将查询编译成紧致高效的机器代码。其目标是提供较好的代码与数据局部性与分支布局，与手写C++代码相媲美。我们将这些技术集成到Hyper主存数据库系统中，只要适中的编译时间，就能达到出色的查询性能。</p>
<h1 id="1-引论"><a href="#1-引论" class="headerlink" title="1. 引论"></a>1. 引论</h1><p>   大多数数据库将给定的查询转换为一个代数（物理的）表达式，然后执行这个代数表达式产生结果。传统典型的执行这些代数的方式是迭代器模型[8], 有时也叫火山式模型[4]。每个物理代数运算符在概念上可以看作从输入产生元组流，可以通过调用重复这个操作符的next函数对元组流迭代。</p>
<p>​    这是很好很简单的接口，可以使得任何操作符容易地组合。很显然，查询处理取决于IO,而CPU消耗显得不是那么重要：首先，每条中间结果或者最终结果的元组产生，都会调用一次next函数，例如，调用上百万次。其次，这个next函数往往以虚函数或者函数指针方式调用，结果是，next调用比正常的调用昂贵得多，并且削弱现代CPU的分支预测效果。第三，这个模型常常导致代码局部性差和复杂的条目登记。考虑到压缩关系的简单表扫描，就可以看到这个问题。由于一次才产生一条元组，表扫描操作符需要记住当前元组压缩流的位置，当要取下一条元组，就需要跳转到对应的解压代码。</p>
<p>这些观察导致一些现代系统已经脱离纯粹迭代模型，无论是内部方式（例如，内部一次解压大量元组然后在解压后的元组数据进行迭代）或者外面模式，一次调用next返回多条元组[11]或者所有的元组[1].这种面向块处理方式通过产生大量元组的方式分摊了调用其他操作符的成本。这样一个元组的调用代价可以忽略不计。但是，这样也消除了迭代模型的主要长处—-数据的<strong>流水线</strong>能力， 流水线意味着一个操作符能将数据传递给父操作符而不需要复制或者物化数据。</p>
<p><img src="/images/FigureHandWriteen.png" alt></p>
<p>以select为例，即一个流水线操作符，仅仅传递元组而不修改。也有更复杂的操作符例如join可以被流水线化，至少在输入这部分可以流水线化，但是在一次调用返回多条元组的情况下，这种纯流水线方式不能再用了，因为元组需要在某地方物化，以供后面访问。物化方式有其他优点，比如允许向量化的操作符[2]，但是通常情况下，没有流水线化往往会消耗更多的内存带宽。</p>
<p>​    本文中一个有趣的观察结果是，如图1，向量化系统尽管已经非常快，但是可以明显看到手写的方式仍然快很多。这个是仍然是在预期的范围内。人类可以使用一些技巧，这些技巧在数据库系统中是不会出现的。在另一方面，图中所示的查询是一种简单的聚合查询，人们期望有合理的方式评估这条查询，因此，使用已经存在的查询评估模式看起来比较理想。</p>
<p>代数操作符模型在查询推导上很有用，但是在查询处理中展示操作符结构不是一个好主意。在本文中，我们提出一个与已有方法不同的查询编译策略，几个重要的不同点如下：</p>
<ol>
<li><p>数据处理以数据为中心，而不是以操作符为中心。这样让CPU尽可能的使用寄存器，为了达到这个目标，操作符之间的边界也就可以模糊不清了。</p>
</li>
<li><p>数据不再是通过操作符拉取，而是主动推送给操作符。这样就可以有较好的代码与数据局部性。</p>
</li>
<li><p>查询使用LLVM优化编译器框架把查询编译成原生机器码</p>
<p>  框架总体上产生的代码对现代的CPU架构十分友好，结果是，速度可以与手写查询计划相媲美。在某些情况下，我们可以使用LLVM的汇编语言直接用手写代码方式生成查询计划， 采用高级语言如C++很难采用的技巧。此外，采用编译框架，我们可以从未来的编译器、代码优化器、以及硬件的发展中收益。而其他的方法则是把处理优化整合到查询引擎中，以后只能手动的更新系统。我们展示了这些技术对的HyPer主存数据库系统的影响，并且与其他系统作比较。</p>
<p>   后续的文章结果如下：首先我们在段2介绍相关工作，然后在段3解释我们的编译框架，段4讨论代数操作符的实际代码生成。在段5中，我们解释集成到框架中的先进处理技术的有何不同。段6 对我们技术进行广泛的评估，并且在段7中给出结论。</p>
<h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2 相关工作"></a>2 相关工作</h2><p>​    查询处理的经典迭代器提出非常早[8], 并且在火山系统[4]较为流行。直至今天，这也是最通过的执行策略，相当简单而且灵活。如果查询处理的性能取决于磁盘IO，则迭代器模型十分奏效。然而，随着CPU消耗成为热点，一些系统尝试降低迭代模型调用产生的高代价，采用的方式是操作符之间传递元组块[11], 这种方式能大幅度降低调用次数，但是带来额外的物化代价。</p>
<p>   现代内存数据库系统重新审视该问题，结果是CPU代价是关键议题。MonetDB系统[1,9]走向另一个极端，物化了所有中间结果，从而消除了输入操作符的重复调用。除了简化操作符交互，物化也有其他的好处，但这也引起显著的代价，MonetDB/X100 系统[1]  (目前已经进化为VectorWise库) 采取了一种中间道路，它采用传递大量的数据向量，并且以向量化的方式为每个块进行计算。这种方式提供了出色的性能，但如图1所示，远没有达到手写代码的速度。</p>
<p>​     另一种提升查询处理的性能是将查询编译成某种可执行格式，而不采用解释的方式，[13]文献中作者提出将查询逻辑编译成成java的ByteCode， 可以由JVM直接执行。但是这种方式相对太重，而且仍然使用迭代器模型，所以收效甚微。最近HIQUE系统中，提出一种将查询的操作符使用代码模版生成C语言 [6], HIQUE通过在操作符执行时，在操作符里内联结果集。然而与我们的方法相反，操作符界限仍然很明确。此外，生成C的代码编译的代价仍然很高[6]</p>
<p>​      除了这些通用的方法外，很多特定的加速查询处理也被提出来。一个重要的工作是减少分支的影响。文献[14]展示如何组合合取连接谓词，在分支数量与谓词运算数量的权衡，而达到优化目的。还有其他的工作，例如，在查询处理中查找可以使用SIMD指令效率更高的个别表达式来做优化。</p>
</li>
</ol>
<h1 id="3-查询编译器"><a href="#3-查询编译器" class="headerlink" title="3 查询编译器"></a>3 查询编译器</h1><h2 id="3-1-查询处理架构"><a href="#3-1-查询处理架构" class="headerlink" title="3.1 查询处理架构"></a>3.1 查询处理架构</h2><p>​     我们提出一种不同的查询处理架构（指查询编译），为了最大化查询处理性能，我们确保数据与代码的局部性最大化。为了解释这点，我们先给出一个定义<strong>pipeline-breaker（流水线中断者，这里的流水线指cpu内指令流水线—译者注）</strong>，这个定义比传统的数据库系统更为严格。如果是一个代数操作是对一个给定的输入方的pipeline-break，意味着输入的元组需要存储在CPU寄存器之外。一个<strong>full pipeline breaker（完全流水线中断者）</strong> 则说明需要把所有输入元组物化，才能继续后续的处理。</p>
<p>​    当一个元组可能太大，在CPU寄存器中放不下，则这个定义向它轻轻的挥手。但是现在我们假装对所有输入的属性都有足够数量的寄存器可用。我们在段4中可以看到更多的细节。其要点是我们要把数据溢出到内存的操作考虑为pipeline-breaker操作。在查询处理过程中，所有的数据尽可能保留在CPU的寄存器中。</p>
<p>​    现在的问题是，如何组织查询处理让数据尽可能保留在CPU的寄存器中呢？经典的迭代器模型显然不合适，因为元组可以从一个函数调用传递到任意个函数— 这就导致寄存器的内容会被替换。面向块的执行模型在函数边界传递的次数更少些。但是很显然，在产生的一批元组如果超过了寄存器的容量，也是会中断流水线的。事实上任何一种迭代器处理范式，从输入操作符拉取数据都有中断流水线的风险，同时，在以迭代器为基础的视角中，它不得不为复杂关系操作符提供一个线性的访问接口。有时候操作符可以便宜代价产生小量的元组，而不需要复制。</p>
<p>   因此，我们可以将数据流控制<strong>弄反</strong> ，与拉取元组不同，我们采用向消费者操作符推送数据。然而推送元组，在没有达到下一个pipeline-breaker，可以持续的推送。结果是，数据<em>一直从一个pipeline-breaker推送到另一个pipline-breaker</em> 。而在此之间的</p>
<p><img src="/images/Fig3ExamplePlan.png" alt></p>
<p>操作符元组都保留在CPU的寄存器中，因而计算代价非常小。此外，在基于推送的架构中，复杂的控制逻辑往往倾向于外置紧密循环，这样就可以减少寄存器压力。由于pipeline-breaker会以任何形式物化元组，我们会生成一个最小化内存访问次数的执行计划。</p>
<p>​     正如图3解释例子的执行计划($\Gamma$ 表示group by操作符) 。对应的SQL查询如图2所示。从$R_2$关系表查询一些元组，以$z$分组，将其结果和$R_3$做连接。  得到的结果与$R_1$的一些元组做连接。在经典的操作符模型中，最顶的join操作符首先要重复询问左边的元组输入是否准备好 ，然后把他们放置到哈西表中，然后询问右边元组输入并为每个表探寻哈西表。而输入方，也是以类似的方式递归操作。如果我们更仔细查看例子的数据流向，我们能看到原则上元组总是从一个物化点传递到另一个物化点。Join a=b的连接操作，从左输入的元组已经物化到哈西表中，并且从物化状态（也就是从$R_1$做扫描）元组。而在流水线之间的select操作符并没有做任何物化。这些物化点如图3右边所示。</p>
<p>​    因为反正我们已经在某个点对元组进行了物化，所以我们打算以一种方式将查询编译出来，使得所有流水线操作符完全由CPU执行（换句话说，没有任何物化），并且从一个物化点执行到另一个物化点。例子对应的编译如图4所示（注意我们假定就计算全在内存中进行，主要是为了例子可读）。</p>
<p><img src="/images/Fig4-Compile.png" alt></p>
<p>除了初始化之外，代码由4段组成，对应代数计划的流水线分段: 第一分段从$R_1$过滤元组并且安置在$\bowtie_{a,b}$的hash表中。第二分段对$R_2$与$\Gamma_z$做了相同的动作，第三分段将$\Gamma_z$的数据到$\bowtie_{z=c}$的hash表。第四个分段传递$R_3$的元组与join哈西表匹配产生结果。所有四个分段自身是强流水线，能保证他们的元组保持在CPU寄存器中，只有在从检索新的元组与物化结果才会访问内存。此外，因为使用紧致循环处理大量数据的小代码分段，使得我们有较好的代码局部性。正因为如此，我们可以期望在这种评估模式下得到非常好的性能。在段6中，我们可以到确实如此。这种查询执行方法远比基于迭代的执行方法好很多。主要的挑战是，如何将一个给定的代数执行计划翻译成这样的代码分段。下一章节我们讨论高层次的翻译，然后在段4中解释真实的代码生成。</p>
<h2 id="3-2-编译代数表达式"><a href="#3-2-编译代数表达式" class="headerlink" title="3.2 编译代数表达式"></a>3.2 编译代数表达式</h2><p>​    看图4的查询代码，我们注意到操作符的界限已经模糊了。例中第一个分段已经组合了$R_1$的扫描与选择$\sigma_{x=7}$ ，并且将$\bowtie_{z=c}$部分也放在一个代码分段中。查询执行代码不再以操作符为中心而是以数据为中心:每个代码分段均是一个执行流水线的一部分，所有动作均在这个流水线完成。然后将结果在下一个pipeline breaker中物化。个别的操作符逻辑可以，最有可能散布在多个代码分段中，导致查询编译更困难。例如，二叉pipeline breaker左输入节点元组的物化，会与右输入节点一个元组的物化大不相同。在迭代器模型中，所有都是一个简单的next调用，但在这里，复杂操作符逻辑直接影响代码生成。重要的是，这是这种方法的优点，而不是其局限！在迭代器模型有这友好，简单的接口，但是要使用虚构函数调用并且有频繁的内存访问。通过暴露操作符结构，我们可以生成接近优化的汇编代码。因为我们在相关给定的情景精确地生成代码，我们可以将所有相关的值保留在CPU的寄存器中。我们在下面可以看到，之前抽象出来的概念还是在代码中保留，用以保证代码可维护性与可读性。例如，所有操作符提供统一的接口，但仅仅存在于查询编译器自身中，生成的代码将所有细节暴露（目的是为了高效），但这样仍然很好，因为代码反正都生成出来了。</p>
<p>​      从查询编译器的观点去看，操作符提供的接口与迭代器模型差不多一样简单。从概念上讲每个操作符提供两个函数:</p>
<ul>
<li>produce()</li>
<li>consume(attributes,source)</li>
</ul>
<p><img src="/images/Fig5Asimpletranslation.png" alt></p>
<p>从概念上讲，<em>produce</em> 函数要求操作符产生结果元组，然后推送到作符调用consume消费。在我们运行的例子中，调用$\bowtie_{a=b}.produce$ 既可以执行查询。这个produce函数内部会调用$\sigma_{x=7}.produce$填充其哈西表，并且$\sigma$ 操作符会调用$R_1.produce$来访问关系。$R_1$是一个操作数的叶，换句话说，其自身是元组的生产者。因此，其过程是扫描关系$R_1$,并且每个元组加载相关属性，然后调用$\sigma_{x=7}.consume(attributes, R_1)$来处理要选择（selection）的元组。selection过滤元组，符合要求的传递给$\bowtie_{a=b}(attribute, \sigma_{x=7})$ . 连接操作从左边获取元组，然后保存到哈西表中。$R_1$所有元组产生之后，控制流返回连接，然后调用$\bowtie_{c=z}.produce$进行搜索等等。</p>
<p>​      然而，这中$proudce/consume$ 接口仅仅是一个心智模型。这些函数并不会显式的存在。仅仅在代码生成的时候使用。当SQL查询被编译时,查询以首先以寻常方式处理 ，换句话说，查询被解析，转换为代数，然后代数表达式被优化。之后我们才偏离标准模式。最终的代数计划没有转换为可执行的物理代数，而是编译成命令程序。只有这个编译步骤内部使用$proudce/consume$ 接口生成所要的命令代码。这个代码生成模型如图5所示，展示转换$\bowtie,\sigma$以及扫描的伪代码，是一个非常简单的翻译模式。读者可以确信，应用图5的规则，能将图3的操作树转换成图4的伪代码(除开不同的变量名和内存初始化)。实际上的翻译代码显然比这更复杂。当然，我们有相关子查询的等情况下，还要跟踪加载的属性，涉及操作符的状态，属性依赖。但在原理上，这种简单对应已经解释了我们如何将代数表达式转换为命令代码。我们在附录A包含了更多的操作符翻译细节。因为这些代码分段总是一次在某小段数据中操作，因此会有非常好的局部性。结果是证实代码可以高效执行。</p>
<h1 id="4-代码生成"><a href="#4-代码生成" class="headerlink" title="4 . 代码生成"></a>4 . 代码生成</h1><h2 id="4-1-生成机器代码"><a href="#4-1-生成机器代码" class="headerlink" title="4.1 生成机器代码"></a>4.1 生成机器代码</h2><p>​     目前为止，我们仅仅讨论将代数表达式翻译成伪代码，但是实际上我们需要将查询编译成机器代码。起初，我们尝试从查询生成C++代码，然后在运行时编译，将编译结果以共享库的方式加载。编译成C++十分吸引人，因为C++代码可以直接访问我们数据库的数据结构和代码，因为这些也是用C++实现的。然而，还是有许多不足之处。首先，C++编译器的优化工程非常慢，编译一个复杂查询需要几秒钟。其次，C++代码并没有提供生成代码的完全控制，完全控制则可以达到理想的性能。实际上，CPU的溢出标志等等不可获取。取而代之的是，我们采用低层虚拟机（LLVM）编译框架来生成可移植的汇编代码。它由LLVM的优化的JIT编译器直接生成，并且可以执行。</p>
<p><img src="/images/Fig6-InteractionOfLLVM.png" alt></p>
<p>然而，起初，使用LLVM生成汇编代码让人望而生畏。但是使用LLVM生成代码比直接手写代码更健壮。例如，LLVM可以提供不限量的寄存数（尽管是单值静态复制形式(SSA)）,向用户隐藏了寄存器分配问题。我们因此可以假装每个元组的属性都能获得CPU的寄存器，大幅度简化生活。并且LLVM汇编是跨机器平台可移植的，只要LLVM JIT编译器将LLVM汇编翻译成所依赖的机器代码。此外，LLVM汇编器是强类型的，能捕捉到C++文本代码生成的隐藏bug。最后，LLVM是一个全强度优化编译器。可以产生极快的机器代码，查询编译通常只需几毫秒，而C或C++编译器至少要几秒(查看段6和[6]).</p>
<p>​    尽管如此，人们还是不愿意用LLVM汇编器去实现完整的查询处理逻辑。首先，编写汇编代码远比写像C++这样的高级代码乏味。其次，因为大部分的数据库逻辑如索引结构已经用C++写了，但是人们可以使用LLVM和C++混合编写，因为C++的方法可以直接有LLVM调用，反之亦然。（对于编译器来说，两种代码没有区别，都生成原生机器代码，都是强类型原型.）这导致如图6所隐喻的混合执行模型。查询处理复杂的部分（例如，复杂数据结构管理，溢出到磁盘）是用C++写的，如图6所示的齿轮。不同的操作符有LLVM代码连接，如图6的链条所示。C++的“齿轮”是预先编译好的，只有组合他们的LLVM的“链条”是动态生成的。因此，我们实现了非常低的编译时间。在具体的例子中，扫描的复杂部分(例如，定位数据结构，指出下一个扫描对象)是用C++实现的，并且这个C++代码驱动执行流水线。但是元组自身的访问以及进一步处理（过滤，物化到哈西表中）是用LLVM汇编代码实现的。C++代码不定时的调用（如分配更多内存），但是C++部分的交互是有LLVM控制的。如果涉及到了复杂操作符如排序，控制权在某些时候完全回到C++，但是一旦复杂逻辑结束，并且元组按块处理，LLVM再次拿回控制权。为了最理想的性能，热点路径就非常重要。换句话说，这块代码执行了99%的元组，则需要纯LLVM，伴随不时的调用C++(例如，切换新页的时候)也很好，其代价可以忽略不计，但是批量的处理必须由LLVM完成。只有在LLVM中时候，我们才能保持元组一直在CPU的寄存器中，接近我们期望的速度。当调用外部函数时，所有的寄存器都会溢出到内存，这代价有点昂贵。当然，所有的寄存器溢出到堆栈中，堆栈通常在CPU的cache中，从绝对量来说，这个代价很便宜。但是，如果执行了数百万次，其代价就明显了。</p>
<h2 id="4-2-复杂操作符"><a href="#4-2-复杂操作符" class="headerlink" title="4.2 复杂操作符"></a>4.2 复杂操作符</h2><p>​     虽然，扫描（scan）与选择（selection）的代码生成或多或少比较直白。但是更复杂的操作符如排序（sort）连接（join）需要小心。首先要记住的是，与在本文目前为止看到的简单例子相反，将复杂查询编译成一个单函数是不可能的，甚至不可取的。这有多方面的原因. 首先，这里有务实的理由：LLVM极可能会调用C++的代码，并且接管流程控制。 例如，一个外部排序的操作符会产生使用的LLVM初始运行，但是可能在C++中控制合并阶段(外部排序有合并阶段—译者注)，根据需要调用LLVM函数。第二个原因是，完全将查询逻辑内联到一个函数会导致代码指数级增长。例如，外部连接在两种不同情景调用其消费函者数，第一个情景是当找到一个匹配的时候，第二个情景是产生NULL值的时候。只有一个的时候可以直接在消费者函数中包含两种情形，但是在级联外部连接会导致代码指数级增长。因此，在LLVM自身中定义函数就有意义，可以有LLVM代码中调用。再次强调，人们要保证热点路径不要跨函数。因此，代数表达式的流水线分段会导致紧致的LLVM代码分段。</p>
<p>​     这种多个函数的必要，会影响我们的代码生成。特别是，当可以在寄存器获取属性值时，我们需要跟踪所有的属性并记住。物化属性到内存中是一个慎重的决定，类似假脱机到磁盘中。当然，不从性能的观点来看，内存的物化相对快，但是从代码的观点看，物化是非常非常复杂的步骤应当尽可能避免。</p>
<p>​      不幸的是，实际上查询的代码生成会迅速变得复杂难懂，这就使得我们不能在这里是展示完成的代码生成计划。但是，正如图7所含的图解，包含了一个非常小的LLVM片段，展示我们部分运行$\Gamma_{z;count(*)}(\sigma_{y=3}(R_2))$ 的主要机制。</p>
<p><img src="/images/Fig7-LLVMFragment.png" alt></p>
<p>在每个数据片段中（换句话说，有序存储的元组序列），LLVM的代码由C++代码调用。LLVM代码首先加载列的指针，然后，然后循环处理所有当前片段的元组（代码已省略）。每个元组，加载属性y到寄存器中，然后检查判断，如果判断为false，则继续循环。反之，加载属性z到寄存器中并且计算哈希值，依据哈希值找到对应的哈西条目(使用C++的数据结构，LLVM可见)，迭代处理每个哈西条目（代码已省略）。如果发现没有匹配的组，然后检查是否有足够的剩余空间来分配新组。如果没有，则调用C++的函数分配新内存，如有必要溢出到磁盘中。这种方式中，热点代码路径始终处于纯LLVM中，大部分的代码存在与%then块中，外加响应的哈西表的迭代。注意到LLVM直接调用原生的C++方法(使用重整的名字@_ZN…), 并没有额外的包装。因此，C++与LLVM互相能直接交互而没有额外的性能惩罚。</p>
<h2 id="4-3-性能调优"><a href="#4-3-性能调优" class="headerlink" title="4.3 性能调优"></a>4.3 性能调优</h2><p>​    使用上面概述的策略LLVM代码生成，速度极快。元组的循环的主要工作完成，则允许很好的内存预取与精确分支预测。事实上，代码如此之快导致突发的代码片段成为瓶颈，只要其他的代码很慢, 这个瓶颈相对不重要。一个突出的例子就是哈西计算。以TPC-H 查询1 (基本上只有一个单扫描与一个基于哈西的聚合)为例，在我们的初始计划中有50%的时间花在哈西计算，即使是只有两个简单的值。另一个关键的问题是分支。在现代的CPU中，只要分支预测起作用，分支的代价非常便宜。换句话说，只要分支近乎不进入或者总是进入。如果进入分支的概率只有50%则破坏了分支预测，分支的代价就非常昂贵。因此，查询编译器需要生成有较好的分支预测的代码。</p>
<p>  在生成汇编代码时，这些问题要小心。如前所提，我们保存元组所有的属性到（虚拟的）CPU寄存器中。对于字符串来说，我们将字符串长度与指针都放在寄存器中。通常情况下，我们尽可能晚加载属性，换句话说，要么在我们需要该属性的那一刻加载，要么在我们必须要访问相应的内存，反正获取属性时候没有代价。计算派生属性也类似。<br>       然而当这些值在关键路径中必要（例如，使用哈希值访问哈希表），比严格必要早一点计算这些值就很合理，其目的是为了隐藏计算的延迟。类似地，分支也要设计好，以适应超高效的CPU执行。例如，如下代码（高级语言）的代码片段对分支预测不友好:</p>
<pre><code>  Entry* iter=hashTable[hash];
  while (iter) {
   ... // inspect the entry
   iter=iter-&gt;next;
  }
</code></pre><p>问题是<em>while</em> 混合了两件事，也就是检查该哈西条目的值是否总是存在，检查是否达到了冲突链表末尾。第一个情况接近总是为true， 因为我们可以预计哈希表已经填充。然而第二个情况接近一直为false，因为冲突链表非常短。因此，如下的代码片段对分支预测会更友好一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry* iter=hashTable[hash];</span><br><span class="line"><span class="keyword">if</span> (iter) <span class="keyword">do</span> &#123;</span><br><span class="line">   ... <span class="comment">// inspect the entry</span></span><br><span class="line">   iter=iter-&gt;next;</span><br><span class="line">&#125; <span class="keyword">while</span> (iter);</span><br></pre></td></tr></table></figure>
<p>​        当然，我们的代码使用LLVM分支而不是C++的循环，但是实质也是一样的，产生如此代码，分支预测效果能显著提升。这种代码布局对查询处理的影响是显而易见的。在我们的实验中，改变分支结构可以提升哈希表查找性能约20%</p>
<p>​     当然，所有这些问题都使得代码生成变得复杂，但是总体上来说，避免这些陷阱的努力不算太严重。反正LLVM代码已经生成，一次代码生成的努力惠及后续的查询。代码生成相对紧凑。我们实现的所有SQL-92的代数操作符的代码生成大约11,000行代码组成，不算太多。</p>
<h1 id="5-高级并行技术"><a href="#5-高级并行技术" class="headerlink" title="5. 高级并行技术"></a>5. 高级并行技术</h1><p>​    在前面的章节我们讨论到如何将查询编译成以数据为中心执行程序。通过组织数据流与控制流以致元组从一个流水线中断（pipeline breaker）推向另一个，并且尽可能长地将数据保存在寄存器中，可以得到极好的数据局部性。然而，这并不意味着我们必须一次一个元组那样，线性地处理元组。我们起初的实现采用推送个别的元组，并且这样性能就很好，但是在通用框架下可以非常自然地整合更先进的处理技术。现在我们看看其中几个。</p>
<p>   传统的按块(block-wise)处理[11]有一个重大缺陷是创建了额外的内存访问。然而，只要我们可以把整个块都放在CPU寄存器中，一次处理多于一条的确实一个好主意。特别是使用使用SIMD寄存器也是常有的事。一次处理多于一条元组的有若干好处：首先，当然，它允许使用现代CPU中的SIMD指令[15]，可以大大加速查询处理。其次，它能帮助延迟分支,因为谓词计算与合取可以不需要立刻进行执行分支[12,14],严格来说，[14]中的技术对个别元组已经非常有用了，但是对元组块来说仍然需要巨大的努力。这种多值包装到一个大的寄存器的块处理样式很自然的符合我们框架。因为操作符总是传递寄存器给器消费者函数。LLVM直接允许模化的SIMD值作为向量类型。然而总体上对代码生成框架的影响相对较小。</p>
<p>​     SIMD指令是一种元组间（inter-tuple）的并行，也就是说，一条指令处理多条元组。第二种与现代CPU有关的并行是多核处理。近乎所有的数据库系统都运用了多核架构提供查询间并行。随着现代CPU的可用的核数增长，查询内并行也越来越重要。[10,3]在原理上研究的很好的问题，通常将操作符的输入分区来解决，独立处理每个分区，然后合并所有分区的结果 。对于我们的的代码生成框架，这种并行可以近乎不修改代码就能支持。</p>
<p>如图7所示，代码总是操作符数据分片，并且在紧致的循环中处理，并且物化到下一个pipeline breaker。通常地，分片由存储系统决定，但是也可以来自并行判定。只有合并到个别结果需要一些额外的逻辑。注意“并行判定”自身就是一个难题！分割与合并数据流很昂贵，优化器关于引入并行必须小心。这已经超出了论文的范围。但是随着核数的增长，这个在将来的工作中是一个相关的问题。</p>
<h1 id="6-评估"><a href="#6-评估" class="headerlink" title="6. 评估"></a>6. 评估</h1><p>​     本文提出的技术我们已经在HyPer主存数据库管理系统和基于磁盘的DBMS实现了[5]. 我们发现这种技术极其有效，无论是纯在内存操作，还是适时假脱机到磁盘中。然而，与其他方法相比精确度量我们的编译技术的影响是比较困难的。因为查询的性能会受其他情况影响巨大，比如不同的存储系统。因此评估分成了两部分：这里我们包含一个完成的系统比较，包含一个生成代码的分析。附录B包含了一个特定操作符行为的微benchmark。</p>
<p>​    在系统比较中，这里包含MonetDB 1.36.5了的实验，Ingres VectorWise 1.0 ,以及商用系统DB X 。所有的实验在Dual Intel X5570 Quad-Core-CPU的64GB，操作系统为Red Hat Enterprise Linux 5.4内存的机器上进行。我们的C++代码使用gcc 4.5.2编译的，机器代码由LLVM2.8生成。在附录C中解释了优化等级的细节。</p>
<h2 id="6-1-系统比较"><a href="#6-1-系统比较" class="headerlink" title="6.1 系统比较"></a>6.1 系统比较</h2><p>​    HyPer系统是一种OLTP（在线事务处理）与OLAP（在线分析处理）的混合系统，集成了我们的查询编译技术。换句话说，它能处理当前两种负载。因此我们使用了TPC-CH基准做实验。OLTP方面运行TPC-C基准， OLAP则使用了22个TPC-H查询适应于（轻度拓展）TPC-C模式。前5条查询参见附录D. 因为这里我们主要兴趣是原生查询处理的速度，我们使用了非并发的设置。也就是说，我们加载了12个数据仓库，然后执行TPC-C单线程事务而且没有客户端等待次数。类似的OLAP查询在12个仓库单线程执行，并且没有并发更新。有趣的是与Hyper原始版本相比， Hyper原始版本使用手写代码片段，将查询编译成C++代码，可以估算出LLVM相对于C++代码的影响。</p>
<p>​       我们在HyPer运行的仅仅是OLTP部分，因为其他系统并不是为OLTP负载设计的。结果如表1所示。</p>
<p><img src="/images/Tab1OLTP.png" alt></p>
<p>在第一行可以看出，以每秒事务数度量，LLVM略微比优化的C++代码性能好。差异很小，虽然大部分的TPC-C事务相对简单，触碰不到30个元组。更有意思的是编译时间，总体上TPC-C脚本(PL/SQL样式的脚本语言)以C++代码编译时间比使用LLVM的编译时间多于十倍。导致（略微）差的性能，这也是我们查询编译技术优势的有力证据。</p>
<p>​    <img src="/images/Tab2OLAP.png" alt></p>
<p>​    在OLAP方面，我们运行TPC-CH查询作为准备查询，并且采取执行一次热机的措施。前五条查询结果如表2所示(查询2(Q2)触发了VectorWise的bug)。 DB X明显比其他系统慢。这个并不奇怪，因为它是为通用基于磁盘的数据库系统（甚至我们采取措施热机数次，所有数据都装在主存中，仍然很慢)。其他系统则更快些，但是是使用LLVM代码生成的HyPer通常比其他的快2~4倍，倍数取决于查询语句。生成C++后端的HyPer与LLVM后端的HyPer对比在这里特别有趣。首先，虽然C++版本相当快，但LLVM后端紧凑的代码生成显著更快。以join为主的Q5相对不明显，但是其他查询，特别是聚合查询Q1，差距十分巨大。Q1中HyPer LVMM表现十分突出。因为在原理上，该查询十分简单，仅仅做了扫描与聚合，对应的C++的代码表现非常自然而高效，但是只不过无法与能将所有的保存到寄存器的LLVM版本相比。从第二个观察值知即使C++交叉编译的查询速度够快，但是其自身的编译时间已经无法接受，这也是我们寻找C++代码生成的替代品的部分原因。LLVM版本的编译时间比较适度（数值包含了所有必要的步骤，包含从SQL字符串转为机器执行码，不只只是LLVM代码生成）。因此HyPer的后端的改变，已经从查询处理自身以及编译时间上得到了回报。</p>
<h2 id="6-2-代码量"><a href="#6-2-代码量" class="headerlink" title="6.2 代码量"></a>6.2 代码量</h2><p>   另一个有趣的点是LLVM生成的代码量。如上所示，性能明显好，但是可以看到有意思的是生成的机器代码分支与缓存的效果。</p>
<p><img src="/images/Tab3BranchingAndCache.png" alt></p>
<p>我们使用<em>callgrind_control</em> 来将性能分析限制在查询处理自身上。</p>
<p>   实验中，我们比较了LLVM版的HyPer与MonetDB， MonetDB以紧致的循环来执行操作符，因此可以认为只有很小的数量的分支预测失败。结果如表3所示。第一个块显示分支预测失败数，第一级指令Cache未命中数(I1), 这些数值反映查询代码的控制流与代码的局部性。有些不是很显著。首先，我们LLVM代码生成比monetDB的分支要少，这个不奇怪，因为我们尝试以线性代码分段方式生成所有的代码，直到下一个pipeline breaker。其次，LLVM代码的分支预测失败的数目也明显低些。有一例外是Q2，但是这是HyPer的次优解行为，与LLVM无关（目前HyPer在假脱机方面非常悲观，会复制大量的字符串，导致60%的分支预测失败，而MonetDB则避免了复制）。其他查询LLVM代码分支预测失效的远少于MonetDB。有趣的是MonetDB的相对预测失效率是很不错的，这可以从MonetDB的架构预估出来，但是总体上MonetDB执行了远太多的分支，导致许多分支预测失效。</p>
<p>​       接下来的块展示了Cache的行为，也就是第一级数据Cache失效(D1)和第二级数据失效(L2d) 。对于大部分的查询来说，这两者数值上非常类似，意味着如果数据不在第一级Cache，很有可能也不在第二级Cache。这是大哈希表所预期的行为。LLVM代码展示了非常好的数据局部性，并且再次比MonetDB更少Cache未命中。因为分支，Q2的字符串处理降低了Cache的效果，但是这个会在HyPer将来的版本解决。但是其他的查询，LLVM代码比MonetDB的远少Cache未命中，高达10倍。</p>
<p>​      最后的块展示的是执行的指令数。这些数字大约与表2的绝对执行时间保持一致，然而不奇怪。虽然，它展示出LLVM生成的代码比MonetDB的代码更紧致。在某种程度上可能根源于MonetDB的架构，总是在二叉关联表(BAT)操作，因此会多次接触元组</p>
<h1 id="7-结论"><a href="#7-结论" class="headerlink" title="7 结论"></a>7 结论</h1><p>​      实验表明，以数据为中心的查询处理方式是一种有效的查询执行模型，通过使用优化的LLVM编译器，将查询编译成机器代码，DBMS可以实现查询处理的效率可以与手写的C++代码相媲美。</p>
<p>​      我们用于将代数编译成LLVM汇编是紧凑的可维护的。因此，以数据为中心的编译方法对所有新的数据库项目都是大有希望的。通过依赖主流编译框架，DBMS可以自动的从将来的编译器发展与处理器升级中获益，而不需要再造查询引擎。</p>
<h1 id="8-引用"><a href="#8-引用" class="headerlink" title="8 引用"></a>8 引用</h1><p>[1] P. A. Boncz, S. Manegold, and M. L. Kersten.Database architecture evolution: Mammals<br>ourished long before dinosaurs became extinct. PVLDB,2(2):1648{1653, 2009.<br>[2] P. A. Boncz, M. Zukowski, and N. Nes.MonetDB/X100: Hyper-pipelining query execution. In<br>CIDR, pages 225{237, 2005.<br>[3] J. Cieslewicz and K. A. Ross. Adaptive aggregation on chip multiprocessors. In VLDB, pages 339{350, 2007.<br>[4] G. Graefe and W. J. McKenna. The Volcano optimizer generator: Extensibility and ecient search. In ICDE,<br>pages 209{218. IEEE Computer Society, 1993.<br>[5] A. Kemper and T. Neumann. HyPer: A hybrid OLTP&amp;OLAP main memory database system based on<br>virtual memory snapshots. In ICDE, pages 195{206,2011.<br>[6] K. Krikellas, S. Viglas, and M. Cintra. Generating code for holistic query evaluation. In ICDE, pages 613{624,2010.<br>[7] C. Lattner and V. S. Adve. LLVM: A compilation framework for lifelong program analysis &amp;<br>transformation. In ACM International Symposium on<br>Code Generation and Optimization (CGO), pages 75{88, 2004.<br>[8] R. A. Lorie. XRM - an extended (n-ary) relational memory. IBM Research Report, G320-2096, 1974.<br>[9] S. Manegold, P. A. Boncz, and M. L. Kersten. Optimizing database architecture for the new<br>bottleneck: memory access. VLDB J., 9(3):231{246,2000.<br>[10] M. Mehta and D. J. DeWitt. Managing intra-operator parallelism in parallel database systems. In VLDB,<br>pages 382{394, 1995.<br>[11] S. Padmanabhan, T. Malkemus, R. C. Agarwal, and A. Jhingran. Block oriented processing of relational<br>database operations in modern computer architectures.In ICDE, pages 567{574, 2001.<br>[12] V. Raman, G. Swart, L. Qiao, F. Reiss, V. Dialani,D. Kossmann, I. Narang, and R. Sidle. Constant-time query processing. In ICDE, pages 60{69, 2008.<br>[13] J. Rao, H. Pirahesh, C. Mohan, and G. M. Lohman.Compiled query execution engine using JVM. In ICDE,<br>page 23, 2006.<br>[14] K. A. Ross. Conjunctive selection conditions in main memory. In PODS, pages 109{120, 2002.<br>[15] T. Willhalm, N. Popovici, Y. Boshmaf, H. Plattner,A. Zeier, and J. Schaner. SIMD-scan: Ultra fast<br>in-memory table scan using on-chip vector processing units. PVLDB, 2(1):385{394, 2009.<br>[16] M. Zukowski, P. A. Boncz, N. Nes, and S. Heman.MonetDB/X100 - a DBMS in the CPU cache. IEEE<br>Data Eng. Bull., 28(2):17{22, 2005.</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="A-操作符翻译"><a href="#A-操作符翻译" class="headerlink" title="A. 操作符翻译"></a>A. 操作符翻译</h2><p>​    由于篇幅的限制，我们在段3只能给一个高度简略的操作符翻译描述。在这里我们讨论更为细节的内容。我们集中看Scan、Select、Project、Map、Hashjion这些操作符。因为这些足够翻译一大类查询。前四个操作符比较简单，使用基础的<em>produce/consume</em> 交互就可以阐明。然而hash join涉及的就要多些。</p>
<p>​    查询编译维护了相当一些基础结构，会在操作符翻译时传递。最重要的对象是<em>codegen</em> ，提供了到LLVM代码生成的接口(-&gt;操作就可以访问LLVM的IRBuilder)，<em>context</em> , 用追踪可获得的属性(包含输入操作符，也包括从”外面”获取的相关的子查询)，<em>getParent</em> 用于获取父节点操作符。此外，也有辅助对象，用于自动化处理LLVM代码生成任务。特别是<em>loop</em>与<em>if</em> 用于自动化处理流程。</p>
<h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a><em>Scan</em></h3><p>​       scan使用<em>ScanConsumer</em> 辅助类来访问所有相关的分段。访问当前分段所包含的所有元组，按需注册所需的列（有context缓存），并且传递元组到消费操作符。注意，依据关系类型，<em>ScanConsumer</em> 逻辑会创建C++的函数调用(例如，页访问)来访问数据分段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void TableScanTranslator::produce(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">	// Access all relation fragments</span><br><span class="line">	llvm::Value* dbPtr=codegen.getDatabasePointer();</span><br><span class="line">	llvm::Value* relationPtr=codegen.getPtr(dbPtr,db.layout.relations[table]);</span><br><span class="line">	auto&amp; required=scanConsumer.getPartitionPtr();</span><br><span class="line">	ScanConsumer scanConsumer(codegen,context);</span><br><span class="line">	for (;db.relations[table]-&gt;generateScan(codegen,relationPtr,scanConsumer);) &#123;</span><br><span class="line">	// Prepare accessing the current fragment</span><br><span class="line">	llvm::Value* partitionPtr=required;</span><br><span class="line">	ColumnAccess columnAccess(partitionPtr,required);</span><br><span class="line">	// Loop over all tuples</span><br><span class="line">	llvm::Value* tid=codegen.const64(0);</span><br><span class="line">	llvm::Value* limit=codegen.load(partitionPtr,getLayout().size);</span><br><span class="line">	Loop loop(codegen,codegen-&gt;CreateICmpULT(tid,limit),&#123;&#123;tid,&quot;tid&quot;&#125;&#125;);</span><br><span class="line">	&#123;</span><br><span class="line">		tid=loop.getLoopVar(0);</span><br><span class="line">		// Prepare column access code</span><br><span class="line">		PartitionAccess::ColumnAccess::Row rowAccess(columnAccess,tid);</span><br><span class="line">		vector&lt;ValueAccess&gt; access;</span><br><span class="line">		for (auto iter=required.begin(),limit=required.end();iter!=limit;++iter)</span><br><span class="line">		access.push_back(rowAccess.loadAttribute(*iter));</span><br><span class="line">		// Register providers in new inner context</span><br><span class="line">		ConsumerContext consumerContext(context);</span><br><span class="line">		unsigned slot=0;</span><br><span class="line">		for (auto iter=required.begin(),limit=required.end();iter!=limit;++iter,++slot)</span><br><span class="line">		consumerContext.registerIUProvider(&amp;(getOutput()[*iter].iu),&amp;access[slot]);</span><br><span class="line">		// Push results to consuming operators</span><br><span class="line">		getParent()-&gt;consume(codegen,consumerContext);</span><br><span class="line">		// Go to the next tuple</span><br><span class="line">		tid=codegen-&gt;CreateAdd(tid,codegen.const64(1));</span><br><span class="line">		loop.loopDone(codegen &gt;CreateICmpULT(tid,limit),ftidg);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为scan是一个叶节点操作符，没有<em>consume</em>部分。</p>
<h3 id="selection"><a href="#selection" class="headerlink" title="selection"></a><em>selection</em></h3><p>selection的<em>produce</em>部分很简单，仅仅加上context所需的谓词，并且调用输入操作符。<em>consume</em> 部分过滤所有不符合要求的元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void SelectTranslator::produce(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">	// Ask the input operator to produce tuples</span><br><span class="line">	AddRequired addRequired(context,getCondition().getUsed());</span><br><span class="line">	input-&gt;produce(codegen,context);</span><br><span class="line">&#125;</span><br><span class="line">void SelectTranslator::consume(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">	// Evaluate the predicate</span><br><span class="line">	ResultValue value=codegen.deriveValue(getCondition(),context);</span><br><span class="line">	// Pass tuple to parent if the predicate is satisfied</span><br><span class="line">	CodeGen::If checkCond(codegen,value);</span><br><span class="line">    &#123;</span><br><span class="line">	  getParent()-&gt;consume(codegen,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a><em>Projection</em></h3><p>(bag) projection差不多没有任何操作。在操作符翻译时，基本没有什么编译，因为它仅仅通知输入有关所需要的列。在pipeline breaker中的才会有实际影响。因为此时需要丢弃所有不需要的列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void ProjectTranslator::produce(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">    // Ask the input operator to produce tuples</span><br><span class="line">    SetRequired setRequired(context,getOutput());</span><br><span class="line">    input-&gt;produce(codegen,context);</span><br><span class="line">&#125;</span><br><span class="line">void ProjectTranslator::consume(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">    // No code required here, pass to parent</span><br><span class="line">    getParent()-&gt;consume(codegen,context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><em>map</em></h3><p>map操作符通过计算函数还计算生成新列，注意计算的位置，并且map与selection的顺序已经在查询优化的时候定好了。因此翻译就很直白</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void MapTranslator::produce(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">    // Figure out which columns have to be provided by the input operator</span><br><span class="line">    IUSet required=context.getRequired();</span><br><span class="line">    for (auto iter=functions.begin(),limit=functions.end();iter!=limit;++iter) &#123; (∗iter).function-&gt;getUsed(required);</span><br><span class="line">    required.erase((∗iter).result);</span><br><span class="line">    &#125;</span><br><span class="line">    // Ask the input operator to produce tuples</span><br><span class="line">    SetRequired setRequired(context,required);</span><br><span class="line">    input-&gt;produce(codegen,context);</span><br><span class="line">&#125;</span><br><span class="line">void MapTranslator::consume(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">    // Offer new columns</span><br><span class="line">    vector&lt;ExpressionAccess&gt; accessors;</span><br><span class="line">    for (auto iter=functions.begin(),limit=functions.end();iter!=limit;++iter)</span><br><span class="line">    accessors.push_back(ExpressionAccess(codegen,∗(∗iter).function));</span><br><span class="line">    for (unsigned index=0,limit=accessors.size();index&lt;limit;index++)</span><br><span class="line">    context.registerIUProvider(functions[index].result,&amp;accessors[index]);</span><br><span class="line">    // Pass to parent</span><br><span class="line">    getParent()-&gt;consume(codegen,context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashJoin"><a href="#hashJoin" class="headerlink" title="hashJoin"></a><em>hashJoin</em></h3><p>以上4个操作符相对简单，大部分可以由纯LLVM代码处理。hashjoin 涉及的更多，因为这里需要从LLVM转到C++代码，然后再转回LLVM。当然，人们也可以只使用LLVM实现hash join，因为纯内存hash join也十分合理。但是，如果期望hash join按需假脱机到磁盘，则需要调用很多与查询独立的方法（例如，I/O）并且这部分我们是用C++写的。</p>
<p>​    我首先用C++代码作为草图，因为它定义了一个代码模版，然后由生成LLVM增强代码。C++ 代码加载生成的数据到内存中，如有必要假脱机到磁盘中。如果数据可以在内存中容纳，则仅仅与probe端做join。反之，则将probe端假脱机到分区中，然后与分区join。为了简单起见，这里仅限于内部join， 非内部join需要额外的登记，用以记住那些元组已经join了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void HashJoin::Inner::produce()</span><br><span class="line">&#123;</span><br><span class="line">// Read the build side</span><br><span class="line">initMem();</span><br><span class="line">produceLeft();</span><br><span class="line">if (inMem) &#123;</span><br><span class="line">	buildHashTable();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Spool remaining tuples to disk</span><br><span class="line">    spoolLeft();</span><br><span class="line">    finishSpoolLeft();</span><br><span class="line">&#125;</span><br><span class="line">// Is a innmemory join possible?</span><br><span class="line">if (inMem) &#123;</span><br><span class="line">    produceRight();</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">// No, spool the right hand side, too</span><br><span class="line">spoolRight();</span><br><span class="line">// Grace hash join</span><br><span class="line">loadPartition(0);</span><br><span class="line">while (true) &#123;</span><br><span class="line">// More tuples on the right?</span><br><span class="line">for (;rightScanRemaining;) &#123;</span><br><span class="line">    const void∗ rightTuple=nextRight();</span><br><span class="line">    for (LookupHash lookup(rightTuple);lookup;++lookup) 	&#123;</span><br><span class="line">    	join(lookup.data(),rightTuple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Handle overflow in n:m case</span><br><span class="line">if (overflow) &#123;</span><br><span class="line">    loadPartitionLeft();</span><br><span class="line">    resetRightScan();</span><br><span class="line">    continue; </span><br><span class="line"> &#125;</span><br><span class="line"> // Go to the next partition</span><br><span class="line"> if ((++inMemPartition)&gt;=partitionCount) &#123;</span><br><span class="line">    return; </span><br><span class="line"> &#125; else &#123;</span><br><span class="line">    loadPartition(inMemPartition);</span><br><span class="line">    &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   因此，LLVM代码提供了三个函数：<em>produce/consume</em> 与上相同，外加<em>join</em> 函数 ，由C++写，能在join的时候需要假脱机到磁盘中的时候直接调用。注意这种情况下的哈希表查询等，已经使用C++实现了，所以 <em>join</em> 只会可能的join候选中调用。<em>produce</em> 函数简单传递控制流到C++代码中。<em>consume</em> 函数（join两边的某一边）哈西了join的值，决定相关的寄存器，并且将它们物化到哈西表中。注意由于性能原因，HyPer系统在没有数据假脱机到磁盘中，则跳过了右边的内存中物化。由于篇幅所限，这里已经省略了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void HJTranslatorInner::produce(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">	// Construct functions that will be be called from the C++ code</span><br><span class="line">	&#123;</span><br><span class="line">		AddRequired addRequired(context,getCondiution().getUsed().limitTo(left));</span><br><span class="line">		produceLeft=codegen.derivePlanFunction(left,context);</span><br><span class="line">	&#125;&#123;</span><br><span class="line">		AddRequired addRequired(context,getCondiution().getUsed().limitTo(right));</span><br><span class="line">		produceRight=codegen.derivePlanFunction(right,context);</span><br><span class="line">	&#125;</span><br><span class="line">	// Call the C++ code</span><br><span class="line">	codegen.call(HashJoinInnerProxy::produce.getFunction(codegen),</span><br><span class="line">		&#123;context.getOperator(this)&#125;);</span><br><span class="line">&#125;</span><br><span class="line">void HJTranslatorInner::consume(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">	llvm::Value∗ opPtr=context.getOperator(this);</span><br><span class="line">	// Left side</span><br><span class="line">	if (source==left) &#123;</span><br><span class="line">		// Collect registers from the left side</span><br><span class="line">		vector&lt;ResultValue&gt; materializedValues;</span><br><span class="line">		matHelperLeft.collectValues(codegen,context,materializedValues);</span><br><span class="line">		// Compute size and hash value</span><br><span class="line">		llvm::Value∗ size=matHelperLeft.computeSize(codegen,materializedValues);</span><br><span class="line">		llvm::Value∗ hash=matHelperLeft.computeHash(codegen,materializedValues);</span><br><span class="line">		// Materialize in hash table, spools to disk if needed</span><br><span class="line">		llvm::Value∗ ptr=codegen.callBase(HashJoinProxy::storeLeftInputTuple,</span><br><span class="line">		&#123;opPtr,size,hash&#125;);</span><br><span class="line">		matHelperLeft.materialize(codegen,ptr,materializedValues);</span><br><span class="line">		// Right side</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// Collect registers from the right side</span><br><span class="line">		vector&lt;ResultValue&gt; materializedValues;</span><br><span class="line">		matHelperRight.collectValues(codegen,context,materializedValues);</span><br><span class="line">		// Compute size and hash value</span><br><span class="line">		llvm::Value∗ size=matHelperRight.computeSize(codegen,materializedValues);</span><br><span class="line">		llvm::Value∗ hash=matHelperRight.computeHash(codegen,materializedValues);</span><br><span class="line">		// Materialize in memory, spools to disk if needed, implicitly joins</span><br><span class="line">		llvm::Value∗ ptr=codegen.callBase(HashJoinProxy::storeRightInputTuple,</span><br><span class="line">										&#123;opPtr,size&#125;);</span><br><span class="line">		matHelperRight.materialize(codegen,ptr,materializedValues);</span><br><span class="line">		codegen.call(HashJoinInnerProxy::storeRightInputTupleDone,&#123;opPtr,hash&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void HJTranslatorInner::join(CodeGen&amp; codegen,Context&amp; context) const</span><br><span class="line">&#123;</span><br><span class="line">    llvm::Value∗ leftPtr=context.getLeftTuple(),∗rightPtr=context.getLeftTuple();</span><br><span class="line">    // Load into registers. Actual load may be delayed by optimizer</span><br><span class="line">    vector&lt;ResultValue&gt; leftValues,rightValues;</span><br><span class="line">    matHelperLeft.dematerialize(codegen,leftPtr,leftValues,context);</span><br><span class="line">    matHelperRight.dematerialize(codegen,rightPtr,rightValues,context);</span><br><span class="line">    // Check the join condition, return false for mismatches</span><br><span class="line">    llvm::BasicBlock∗ returnFalseBB=constructReturnFalseBB(codegen);</span><br><span class="line">    MaterializationHelper::testValues(codegen,leftValues,rightValues,</span><br><span class="line">    joinPredicateIs,returnFalseBB);</span><br><span class="line">    for (auto iter=residuals.begin(),limit=residuals.end();iter!=limit;++iter) &#123;</span><br><span class="line">        ResultValue v=codegen.deriveValue(∗∗iter,context);</span><br><span class="line">        CodeGen::If checkCondition(codegen,v,0,returnFalseBB);</span><br><span class="line">	&#125;</span><br><span class="line">    // Found a match, propagate up</span><br><span class="line">    getParent())&gt;consume(codegen,context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​     </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><em>示例</em></h3><p>作为解释用的小例子，这里我们展示如下查询用的LLVM生成代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select d_tax from warehouse, district</span><br><span class="line">where w_id=d_w_id and w_zip=’137411111’</span><br></pre></td></tr></table></figure>
<p>它首先扫描<code>warehouse</code>, 过滤，物化到哈西表中。然后扫描 <em>distinct</em> 再做join。 注意我们“强制”使用纯主存hash join，保持代码大小合理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">define void @planStart(%14∗ %executionState) &#123;</span><br><span class="line">body:</span><br><span class="line">    %0 = getelementptr inbounds %14∗ %executionState, i64 0, i32 0, i32 1,</span><br><span class="line">    i64 0</span><br><span class="line">    store i64 0, i64∗ %0, align 8</span><br><span class="line">    %1 = getelementptr inbounds %14∗ %executionState, i64 0, i32 1</span><br><span class="line">    call void @ ZN5hyper9HashTable5resetEv(%”hyper::HashTable”∗ %1)</span><br><span class="line">    %2 = bitcast %14∗ %executionState to %”hyper::Database”∗∗</span><br><span class="line">    %3 = load %”hyper::Database”∗∗ %2, align 8</span><br><span class="line">    %4 = getelementptr inbounds %”hyper::Database”∗ %3, i64 0, i32 1</span><br><span class="line">    %5 = load i8∗∗ %4, align 8</span><br><span class="line">    %warehouse = getelementptr inbounds i8∗ %5, i64 5712</span><br><span class="line">    %6 = getelementptr inbounds i8∗ %5, i64 5784</span><br><span class="line">    %7 = bitcast i8∗ %6 to i32∗∗</span><br><span class="line">    %8 = load i32∗∗ %7, align 8</span><br><span class="line">    %9 = getelementptr inbounds i8∗ %5, i64 5832</span><br><span class="line">    %10 = bitcast i8∗ %9 to %3∗∗</span><br><span class="line">    %11 = load %3∗∗ %10, align 8</span><br><span class="line">    %12 = bitcast i8∗ %warehouse to i64∗</span><br><span class="line">    %size = load i64∗ %12, align 8</span><br><span class="line">    %13 = icmp eq i64 %size, 0</span><br><span class="line">    br i1 %13, label %scanDone, label %scanBody</span><br><span class="line">scanBody:</span><br><span class="line">    %tid = phi i64 [ 0, %body ], [ %34, %cont2 ]</span><br><span class="line">    %14 = getelementptr i32∗ %8, i64 %tid</span><br><span class="line">    %w id = load i32∗ %14, align 4</span><br><span class="line">    %15 = getelementptr inbounds %3∗ %11, i64 %tid, i32 0</span><br><span class="line">    %16 = load i8∗ %15, align 1</span><br><span class="line">    %17 = icmp eq i8 %16, 9</span><br><span class="line">    br i1 %17, label %then, label %cont2</span><br><span class="line">then:</span><br><span class="line">    %w zip = getelementptr inbounds %3∗ %11, i64 %tid, i32 1, i64 0</span><br><span class="line">    %27 = call i32 @memcmp(i8∗ %w zip, i8∗ @”string 137411111”, i64 9)</span><br><span class="line">    %28 = icmp eq i32 %27, 0</span><br><span class="line">    br i1 %28, label %then1, label %cont2</span><br><span class="line">then1:</span><br><span class="line">    %29 = zext i32 %w id to i64</span><br><span class="line">    %30 = call i64 @llvm.x86.sse42.crc64.64(i64 0, i64 %29)</span><br><span class="line">    %31 = shl i64 %30, 32</span><br><span class="line">    %32 = call i8∗ @ ZN5hyper9HashTable15storeInputTupleEmj(%”hyper::</span><br><span class="line">    HashTable”∗ %1, i64 %31, i32 4)</span><br><span class="line">    %33 = bitcast i8∗ %32 to i32∗</span><br><span class="line">    store i32 %w id, i32∗ %33, align 1</span><br><span class="line">    br label %cont2</span><br><span class="line">cont2:</span><br><span class="line">    %34 = add i64 %tid, 1</span><br><span class="line">    %35 = icmp eq i64 %34, %size</span><br><span class="line">    br i1 %35, label %cont2.scanDone crit edge, label %scanBody</span><br><span class="line">    cont2.scanDone crit edge:</span><br><span class="line">    %.pre = load %”hyper::Database”∗∗ %2, align 8</span><br><span class="line">    %.phi.trans.insert = getelementptr inbounds %”hyper::Database”∗ %.pre,</span><br><span class="line">    i64 0, i32 1</span><br><span class="line">    %.pre11 = load i8∗∗ %.phi.trans.insert, align 8</span><br><span class="line">    br label %scanDone</span><br><span class="line">scanDone:</span><br><span class="line">    %18 = phi i8∗ [ %.pre11, %cont2.scanDone crit edge ], [ %5, %body ]</span><br><span class="line">    %district = getelementptr inbounds i8∗ %18, i64 1512</span><br><span class="line">    %19 = getelementptr inbounds i8∗ %18, i64 1592</span><br><span class="line">    %20 = bitcast i8∗ %19 to i32∗∗</span><br><span class="line">    %21 = load i32∗∗ %20, align 8</span><br><span class="line">    %22 = getelementptr inbounds i8∗ %18, i64 1648</span><br><span class="line">    %23 = bitcast i8∗ %22 to i64∗∗</span><br><span class="line">    %24 = load i64∗∗ %23, align 8</span><br><span class="line">    %25 = bitcast i8∗ %district to i64∗</span><br><span class="line">    %size8 = load i64∗ %25, align 8</span><br><span class="line">    %26 = icmp eq i64 %size8, 0</span><br><span class="line">    br i1 %26, label %scanDone6, label %scanBody5</span><br><span class="line">scanBody5:</span><br><span class="line">    %tid9 = phi i64 [ 0, %scanDone ], [ %58, %loopDone ]</span><br><span class="line">    %36 = getelementptr i32∗ %21, i64 %tid9</span><br><span class="line">    %d w id = load i32∗ %36, align 4</span><br><span class="line">    %37 = getelementptr i64∗ %24, i64 %tid9</span><br><span class="line">    %d tax = load i64∗ %37, align 8</span><br><span class="line">    %38 = zext i32 %d w id to i64</span><br><span class="line">    %39 = call i64 @llvm.x86.sse42.crc64.64(i64 0, i64 %38)</span><br><span class="line">    %40 = shl i64 %39, 32</span><br><span class="line">    %41 = getelementptr inbounds %14∗ %executionState, i64 0, i32 1, i32 0</span><br><span class="line">    %42 = load %”hyper::HashTable::Entry”∗∗∗ %41, align 8</span><br><span class="line">    %43 = getelementptr inbounds %14∗ %executionState, i64 0, i32 1, i32 2</span><br><span class="line">    %44 = load i64∗ %43, align 8</span><br><span class="line">    %45 = lshr i64 %40, %44</span><br><span class="line">    %46 = getelementptr %”hyper::HashTable::Entry”∗∗ %42, i64 %45</span><br><span class="line">    %47 = load %”hyper::HashTable::Entry”∗∗ %46, align 8</span><br><span class="line">    %48 = icmp eq %”hyper::HashTable::Entry”∗ %47, null</span><br><span class="line">    br i1 %48, label %loopDone, label %loop</span><br><span class="line">loopStep:</span><br><span class="line">    %49 = getelementptr inbounds %”hyper::HashTable::Entry”∗ %iter, i64 0,</span><br><span class="line">    i32 1</span><br><span class="line">    %50 = load %”hyper::HashTable::Entry”∗∗ %49, align 8</span><br><span class="line">    %51 = icmp eq %”hyper::HashTable::Entry”∗ %50, null</span><br><span class="line">    br i1 %51, label %loopDone, label %loop</span><br><span class="line">loop:</span><br><span class="line">    %iter = phi %”hyper::HashTable::Entry”∗ [ %47, %scanBody5 ], [ %50, %</span><br><span class="line">    loopStep ]</span><br><span class="line">    %52 = getelementptr inbounds %”hyper::HashTable::Entry”∗ %iter, i64 1</span><br><span class="line">    %53 = bitcast %”hyper::HashTable::Entry”∗ %52 to i32∗</span><br><span class="line">    %54 = load i32∗ %53, align 4</span><br><span class="line">    %55 = icmp eq i32 %54, %d w id</span><br><span class="line">    br i1 %55, label %then10, label %loopStep</span><br><span class="line">then10:</span><br><span class="line">    call void @ ZN6dbcore16RuntimeFunctions12printNumericEljj(i64 %d tax,</span><br><span class="line">    i32 4, i32 4)</span><br><span class="line">    call void @ ZN6dbcore16RuntimeFunctions7printNlEv()</span><br><span class="line">    br label %loopStep</span><br><span class="line">loopDone:</span><br><span class="line">    %58 = add i64 %tid9, 1</span><br><span class="line">    %59 = icmp eq i64 %58, %size8</span><br><span class="line">    br i1 %59, label %scanDone6, label %scanBody5</span><br><span class="line">scanDone6:</span><br><span class="line">	ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-微BENCHMARK"><a href="#B-微BENCHMARK" class="headerlink" title="B. 微BENCHMARK"></a>B. 微BENCHMARK</h2><p>​     除了主实验之外，我们还使用一些微bechmark来更详细地研究不同查询处理模式。我们子HyPer系统实现若干技术并运行之。这种方式下，所有方法从相同的结构读取相同的数据，因此任何运行时的差异纯粹来自有查询处理的控制流差异。除了<em>数据中心编译</em> 模式外，我们还是实现了经典的 <em>迭代器模型</em> ，包含了<em>解释器</em> （换句话说，大部分数据库标准执行模式），以及<em>编译</em> 到执行代码的模式。此外，我们实现了分块元组处理[11], 大致与现代的Cache-consious（Cache敏感）数据库类型，如MonetDB与VectorWise。我们这里仅仅考虑编译模型，因为MonetDB与VectorWise都是预编译技术创建块来减少解释开销。注意在实验中，数据都是列式存储，换句话说，访问更多的列会增加扫描数据量。</p>
<p>   起初，我们使用非常简单的聚合查询来查询TPC-C数据集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(*)</span><br><span class="line">from orderline</span><br><span class="line">where ol_o_id&gt;0 and ol_d_id&gt;0 and ol_w_id&gt;0</span><br></pre></td></tr></table></figure>
<p>变换过滤条件的个数，并且这些都没有选择性(换句话说，任何条件合取，得到的结果都是一样的)。因为我们对数据传递的开销感兴趣，每个过滤条件以独立的selection 操作符导入。然后在不同执行模式下度量执行时间，结果如图8所示。</p>
<p><img src="/images/Fig8CascadeSelection.png" alt></p>
<p>可以清楚看到，使用解释方法做谓词检查的迭代器模型（换句话说，就是目前大部分数据库执行模式）非常慢。它执行了大量的函数调用，而局部性少的可怜。而编译成执行码的迭代器模型运行性能大大提升。特别是因为谓词计算的虚函数被消除了。很显然，编译成机器码是一个好主意，而解释方法就明显慢了些。分块执行模型性能更好，在没有条件的情况下，有一点慢。因为有查找块边界，建立块frame的代价等等，这种情况下，分块没有任何回报。但是，只有一个selection，则有减少函数调用，以及更好的局部性的回报，与迭代器方式相比表现的十分出色。而数据为中心的方法在所有的查询中则表现出极度优秀的性能。特别是在这两点有趣：在没有携带任何条件的情况下，执行的时间接近为0. 这是因为，编译注意到元组上的循环除了增加计数之外，基本不干其他事情，并且将其转换为计算分段大小之和。其次，当过滤所有的三列，性能下降很快。但是实际上，是因为两个过滤条件的情况下，有cache的效应，太快了。三个过滤的查询以4.2GB/s去读元组属性，已经接近我们机器内存的带宽。我们可以使用条件CPU操作来提高查询处理，但是通常的selection代码我们不能期望它更快了。</p>
<p><img src="/images/Fig9PerformanceAggreQue.png" alt></p>
<p>   在第二个实验中，我们看一个与第一个查询“相反的”查询:第一个查询我们使用元组过滤操作符但是不执行计算。现在我们消除selection，基于属性做计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select sum(ol_o_id*ol_d_id*ol_w_id)</span><br><span class="line">from orderline</span><br></pre></td></tr></table></figure>
<p>   为了改变复杂性，我们做了只计算一个项聚合的查询，两个项乘积的聚合查询，与所有三个乘积聚合的查询。结果如图9所示。迭代解释器模型又一次表现得很慢。虽然，迭代编译模型表现的好一点，现在一个元组只要一个虚函数调用。而面向块的方法仍然更快一点，但是差距很小。又一次，以数据为中心的方法性能极其优秀。当执行三列的聚合查询高到6.5GB/s, 已经接近内存总线的带宽了。我们的查询处理这么快，以致“I/O墙”，这里的IO变成RAM的访问了。</p>
<h2 id="C-优化设置"><a href="#C-优化设置" class="headerlink" title="C. 优化设置"></a>C. 优化设置</h2><p>   生成机器代码的时候，优化设置对性能结果有极大的影响。因此，我们给出了实验中优化设置的准确描述：</p>
<p>   C++代码中，使用g++ 4.5.2来生成机器代码，优化标签如下：</p>
<p><code>-O3 -fgcse-las -funsafe-loop-optimizations.</code></p>
<p>​     注意，在gcc 4.5版本中，这里包含了其他优化选项，如<code>-ftree-vectorize</code> ,在monetDB中需要显式指定。这个优化选项可以得到最大的查询性能。例子中指定-funroll-loops 则在Q4中性能下降23%。 与优化选项交互十分微妙。例如，指定-funroll-loops 又指定 影响寄存器分配的-fweb。因此，预测独立的编译开关的影响是很困难的。</p>
<p>   LLVM编译我们通过手动调度优化趟数(optimization pass)自定义的优化级别。如下所列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">llvm::createInstructionCombiningPass()</span><br><span class="line">llvm::createReassociatePass()</span><br><span class="line">llvm::createGVNPass()</span><br><span class="line">llvm::createCFGSimplificationPass()</span><br><span class="line">llvm::createAggressiveDCEPass()</span><br><span class="line">llvm::createCFGSimplificationPass()</span><br></pre></td></tr></table></figure>
<p>   由于我们的SQL编译可以产生非常合理的LLVM代码，我们主要依赖optimization pass来优化控制流程，结果是与激进的LLVM优化级别相比，优化所用时间很短。</p>
<h2 id="D-查询语句"><a href="#D-查询语句" class="headerlink" title="D. 查询语句"></a>D. 查询语句</h2><p>我们这里列出Q1~Q5完整的查询语句。如[5]所述，这些是TPC-H查询派生出来的，但是适应于TPC-C和TPC-H模式组合。 </p>
<p><strong>Q1</strong> </p>
<p><strong>select</strong> ol number, <strong>sum</strong>(ol quantity) <strong>as</strong> sum qty, </p>
<p><strong>sum</strong>(ol amount) <strong>as</strong> sum amount, <strong>avg</strong>(ol quantity) <strong>as</strong> avg qty, </p>
<p><strong>avg</strong>(ol amount) <strong>as</strong> avg amount, <strong>count</strong>(<em>∗</em>) <strong>as</strong> count order </p>
<p><strong>from</strong> orderline </p>
<p><strong>where</strong> ol delivery d<em>&gt;**</em>timestamp** ’2010-01-01 00:00:00’ </p>
<p><strong>group by</strong> ol number </p>
<p><strong>order by</strong> ol number </p>
<p><strong>Q2</strong> </p>
<p><strong>select</strong> su suppkey, su name, n name, i id, </p>
<p>i name, su address, su phone, su comment </p>
<p><strong>from</strong> item, supplier, stock, nation, region </p>
<p><strong>where</strong> i id = s i id </p>
<p><strong>and</strong> mod((s w id <em>∗</em> s i id), 10000) = su suppkey </p>
<p><strong>and</strong> su nationkey = n nationkey </p>
<p><strong>and</strong> n regionkey = r regionkey </p>
<p><strong>and</strong> i data <strong>like</strong> ’%b’ <strong>and</strong> r name <strong>like</strong> ’Europ%’ </p>
<p><strong>and</strong> s quantity = ( </p>
<p><strong>select min</strong>(s quantity) </p>
<p><strong>from</strong> stock, supplier, nation, region </p>
<p><strong>where</strong> i id = s i id </p>
<p><strong>and</strong> mod((s w id <em>∗</em> s i id),10000) = su suppkey </p>
<p><strong>and</strong> su nationkey = n nationkey </p>
<p><strong>and</strong> n regionkey = r regionkey </p>
<p><strong>and</strong> r name <strong>like</strong> ’Europ%’ ) </p>
<p><strong>order by</strong> n name, su name, i id </p>
<p><strong>Q3</strong> </p>
<p><strong>select</strong> ol o id , ol w id, ol d id , <strong>sum</strong>(ol amount) <strong>as</strong> revenue, o entry d </p>
<p><strong>from</strong> customer, neworder, ”order”, orderline </p>
<p><strong>where</strong> c state <strong>like</strong> ’A%’ </p>
<p><strong>and</strong> c id = o c id <strong>and</strong> c w id = o w id <strong>and</strong> c d id = o d id </p>
<p><strong>and</strong> no w id = o w id <strong>and</strong> no d id = o d id <strong>and</strong> no o id = o id </p>
<p><strong>and</strong> ol w id = o w id <strong>and</strong> ol d id = o d id <strong>and</strong> ol o id = o id </p>
<p><strong>and</strong> o entry d <em>&gt;</em> <strong>timestamp</strong> ’2010<em>0</em>01<em>1</em>01 00:00:00’ </p>
<p><strong>group by</strong> ol o id, ol w id, ol d id , o entry d </p>
<p><strong>order by</strong> revenue <strong>desc</strong>, o entry d </p>
<p><strong>Q4</strong> </p>
<p><strong>select</strong> o ol cnt , <strong>count</strong>(<em>∗</em>) <strong>as</strong> order count </p>
<p><strong>from</strong> ”order” </p>
<p><strong>where</strong> o entry d <em>&gt;</em>= <strong>timestamp</strong> ’2010<em>0</em>01<em>1</em>01 00:00:00’ </p>
<p><strong>and</strong> o entry d <em>&lt;</em> <strong>timestamp</strong> ’2110<em>0</em>01<em>1</em>01 00:00:00’ </p>
<p><strong>and exists</strong> (<strong>select</strong> <em>∗</em> <strong>from</strong> orderline </p>
<p><strong>where</strong> o id = ol o id <strong>and</strong> o w id = ol w id <strong>and</strong> o d id = ol d id </p>
<p><strong>and</strong> ol delivery d <em>&gt;</em> o entry d) </p>
<p><strong>group by</strong> o ol cnt </p>
<p><strong>order by</strong> o ol cnt </p>
<p><strong>Q5</strong> </p>
<p><strong>select</strong> n name, <strong>sum</strong>(ol amount) <strong>as</strong> revenue </p>
<p><strong>from</strong> customer, ”order”, orderline, stock, supplier , nation, region </p>
<p><strong>where</strong> c id = o c id <strong>and</strong> c w id = o w id <strong>and</strong> c d id = o d id </p>
<p><strong>and</strong> ol o id = o id <strong>and</strong> ol w id = o w id <strong>and</strong> ol d id=o d id </p>
<p><strong>and</strong> ol w id = s w id <strong>and</strong> ol i id = s i id </p>
<p><strong>and</strong> mod((s w id <em>∗</em> s i id),10000) = su suppkey </p>
<p><strong>and</strong> ascii(<strong>substr</strong>(c state,1,1)) = su nationkey </p>
<p><strong>and</strong> su nationkey = n nationkey </p>
<p><strong>and</strong> n regionkey = r regionkey <strong>and</strong> r name = ’Europa’ </p>
<p><strong>and</strong> o entry d <em>&gt;</em>= <strong>timestamp</strong> ’2010<em>0</em>01<em>1</em>01 00:00:00’ </p>
<p><strong>group by</strong> n name </p>
<p><strong>order by</strong> revenue <strong>desc</strong></p>

      
    </div>
    
	<! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   欣赏此文？求鼓励，求支持！
        </span>
        <br>
      </div>  
	<div id="donate_guide" class="donate_bar center hidden" >
		<!-- 支付宝打赏图案 -->
		<img src="/images/zhifubao.png" alt="支付宝打赏"> 
		<!-- 微信打赏图案 -->
		<img src="/images/weixin.jpg" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</div>
<! -- 添加捐赠图标 -->
	
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/现代硬件的高效查询计划的高效编译/" data-id="ck04u7fq6000dycflc2jrp4te" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/“database”/">“database”</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/28/如何从0写编译器/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          如何从0写编译器
        
      </div>
    </a>
  
  
    <a href="/2019/07/02/神奇的自然底数e/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">神奇的自然底数e</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/“about”/">“about”</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/“database”/">“database”</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学/">数学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数学-算法/">数学,算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/“about”/" style="font-size: 10px;">“about”</a> <a href="/tags/“database”/" style="font-size: 20px;">“database”</a> <a href="/tags/数学/" style="font-size: 10px;">数学</a> <a href="/tags/数学-算法/" style="font-size: 10px;">数学,算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/04/一道面试题想到的/">一道面试题想到的</a>
          </li>
        
          <li>
            <a href="/2019/07/28/如何从0写编译器/">如何从0写编译器</a>
          </li>
        
          <li>
            <a href="/2019/07/08/现代硬件的高效查询计划的高效编译/">现代硬件的高效查询计划的高效编译</a>
          </li>
        
          <li>
            <a href="/2019/07/02/神奇的自然底数e/">神奇的自然底数e</a>
          </li>
        
          <li>
            <a href="/2019/06/30/基于现代硬件的数据库/">基于现代硬件的数据库</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>